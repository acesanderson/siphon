"""
A SiphonQuery class to handle siphon queries.

This provides a universal interface for querying a ProcessedCorpus object, whether it's the entire library, a subset, a created-on-the-fly corpus (from a directory, fex.), etc.

This module is part of the Siphon project, which is designed to manage and process content from various sources.

This embraces the monad pattern, meaning you can daisy conduit methods together to create complex queries, for example:
SiphonQuery().last().filter_by_date("2023-01-01").filter_by_source("example_source"). This is achieved by returning a new SiphonQuery instance with the updated parameters at each step.

SiphonQueries are able to access metadata, content, and other attrs in a SQL-like manner, but also have access to vector database queries for semantic search, graph queries for GraphRAG, and synthetic/AI-generated tagging/summarization access. These are generated by the ProcessedCorpus objects, but in a lazy manner -- i.e. when initiated by a specific SiphonQuery method. Example:
class SiphonQuery:
    def semantic_search(self, query: str, k: int = 10) -> 'SiphonQuery':
        # This triggers vector DB creation if it doesn't exist
        if not self.corpus.has_vector_index():
            self.corpus._create_vector_index()  # Happens here, not at init
        # Then do the search
        return self._add_operation('semantic_search', query, k)

NOTE: for now, SiphonQuery has all the query logic, and performs on an InMemoryCorpus. In the future, we would want to abstract these methods into InMemoryCorpus, as well as DatabaseCorpus (i.e. SQL and our persistent databases).
"""

from siphon.data.processed_content import ProcessedContent
from siphon.logs.logging_config import get_logger
from siphon.data.type_definitions.source_type import SourceType
from siphon.collections.corpus.siphon_corpus import (
    SiphonCorpus,
    InMemoryCorpus,
)
from typing import Literal

logger = get_logger(__name__)


class SiphonQuery:
    """
    Monadic query interface for fluent corpus operations
    """

    def __init__(self, corpus: SiphonCorpus):
        self.corpus: SiphonCorpus = corpus

    # ========================================================================
    # Monadic operations return new SiphonQuery instances
    # ========================================================================

    # Filtering Operations (return new SiphonQuery)

    def filter_by_source_type(
        self, source_type: SourceType | list[SourceType]
    ) -> "SiphonQuery":
        # Coerce sourcetype to list if not already
        if not isinstance(source_type, list):
            source_type = [source_type]
        filtered = self.corpus.filter(lambda x: x.source_type in source_type)
        return SiphonQuery(filtered)

    def filter_by_date_range(self, start_date: str, end_date: str) -> "SiphonQuery":
        """
        Dates are ISO format strings: "YYYY-MM-DD"
        """
        filtered = self.corpus.filter(lambda x: start_date <= x.date <= end_date)
        return SiphonQuery(filtered)

    def filter_by_tags(self, tags: list[str]) -> "SiphonQuery": ...

    def filter_by_content(self, search_term: str) -> "SiphonQuery":
        filtered = self.corpus.filter(lambda x: search_term in x.context)
        return SiphonQuery(filtered)

    def filter_by_title(self, title_pattern: str) -> "SiphonQuery":
        filtered = self.corpus.filter(lambda x: title_pattern in x.title)
        return SiphonQuery(filtered)

    # Ordering & Limiting (return new SiphonQuery)

    def order_by_date(self, ascending: bool = True) -> "SiphonQuery":
        ordered = self.corpus.sort(key=lambda x: x.date, reverse=not ascending)
        return SiphonQuery(ordered)

    def order_by_title(self, ascending: bool = True) -> "SiphonQuery":
        ordered = self.corpus.sort(key=lambda x: x.title, reverse=not ascending)
        return SiphonQuery(ordered)

    def limit(self, n: int) -> "SiphonQuery":
        limited = self.corpus[:n]
        return SiphonQuery(limited)

    def offset(self, n: int) -> "SiphonQuery":
        offsetted = self.corpus[n:]
        return SiphonQuery(offsetted)

    def paginate(self, page_size: int, page_number: int) -> "SiphonQuery":
        start = page_size * (page_number - 1)
        end = start + page_size
        paginated = self.corpus[start:end]
        return SiphonQuery(paginated)

    # Advanced Queries (return new SiphonQuery)

    def semantic_search(
        self,
        query: str,
        k: int = 10,
        dataset: Literal["description", "chunked"] = "description",
    ) -> "SiphonQuery":
        # This triggers vector DB creation if it doesn't exist
        if not self.corpus.vector_store_created:
            self.corpus._create_vector_store()
        match dataset:
            case "description":
                collection = self.corpus.description_collection
            case "chunked":
                collection = self.corpus.chunked_context_collection
            case _:
                raise ValueError(f"Unknown dataset: {dataset}")
        results = self.corpus._query_vector_store(collection, query, k)
        return results

    def similar_to(self, content: ProcessedContent, k: int = 10) -> "SiphonQuery": ...

    def graph_traverse(
        self, start_content: ProcessedContent, depth: int = 2
    ) -> "SiphonQuery": ...

    # Aggregation Operations (return new SiphonQuery)

    def group_by_source_type(self) -> "SiphonQuery": ...

    def group_by_date(self, granularity: str = "day") -> "SiphonQuery": ...

    # ========================================================================
    # Terminal Operations (return non-SiphonQuery results)
    # ========================================================================

    def to_list(self) -> list[ProcessedContent]: ...

    def to_corpus(self) -> InMemoryCorpus: ...

    def to_sourdough(self, **kwargs) -> "Sourdough": ...

    def to_dataframe(self): ...

    def first(self) -> ProcessedContent | None: ...

    def last(self) -> ProcessedContent | None: ...

    def count(self) -> int: ...

    def exists(self) -> bool: ...

    # ========================================================================
    # View & Utility Methods
    # ========================================================================

    def snapshot(self) -> str:
        """Get a snapshot summary of the current query state"""
        return self.corpus.snapshot()


if __name__ == "__main__":
    from siphon.collections.corpus.siphon_corpus import DatabaseCorpus

    query = DatabaseCorpus().query()
    results = query.semantic_search(
        "Best practices for Retrieval Augmented Generation with LLMs", k=5
    )
    print(results)
